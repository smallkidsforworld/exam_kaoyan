## 虚拟机相关
   - jvm自动内存管理
   ![blockchain](https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190208123758382-331193994.png)
      - 线程共享的区域:
         - 方法区:存储加载的类型信息,常量,静态变量(非堆),
         - 堆:存放对象实例,以及数组.
            - 如果没有完成对象的实例分配,并且堆无法扩展,抛出OOM异常.
      - 线程独占的区域
         - 虚拟机栈:每个方法执行时候的一个栈帧,用来存储对应的局部变量表,操作数栈,动态链接,方法出口等.
            - 抛出stackoverflow异常:申请的空间大于虚拟机设定的最大空间
            - 抛出outofmemory异常:栈动态扩展时,无法申请到空间.
         - 本地方法栈:虚拟机使用的本地(native方法)服务.
         - 程序计数器:当前线程执行字节码的行好指示器.
      - 直接内存(NIO等)
         - 基于通道和Buffer的IO方式,
   - 对象
      - 对象的创建:
      - 对象头的组成
---
   - 垃圾回收GC
      - 对象引用
         - 强引用: = new 类型的
         - 软引用: SoftReference实现软引用.系统将要内存溢出之前,会回收
         - 弱引用: WeakReference实现弱引用,下一次回收一定会回收的对象.
         - 虚引用: 
      - 可达性分析(标记算法):
         - 设定gc root,通过算法判断无法到达gc root的对象,将被标记回收.
         - gc root:
            - 所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。
            - VM的一些静态数据结构里指向GC堆里的对象的引用
      - 分代收集算法
         - JAVA堆分为新生代,老年代.
         - 新生代:大量对象死去,剩下的对象逐渐过度到老年代
         - 三大特点:
            - 新生代收集的对象数量最多
            - 存活时间越长的对象,越难以收集
            - 跨代调用的对象很少.
         - 标记-清除算法
         - 标记-复制算法 
         - 标记-整理算法(一般针对老年代)
      - GC种类
         - CMS:收集器是一种以获取最短回收停顿时间为目标的收集器，使用标记-清除算法。初始标记(gc root)->并发标记(标记不可达)->重新标记(增量添加不可达)->并发清除
         - G1:[G1的i详细解释](https://blog.csdn.net/coderlius/article/details/79272773?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-1&spm=1001.2101.3001.4242)
---
   - 类加载
      - 类加载过程
      ![blockchain](https://upload-images.jianshu.io/upload_images/13202633-3cb11d1712a9efc9.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
         - 加载部分:
            - 根据类全限定名获取定义此类的二进制字节流.
            - 生成方法区运行时的数据结构
            - 堆中生成一个对应的Class对象,作为访问方法区域的入口
         - 校验部分
            - 文件格式验证:字节码格式是否符合jvm要求,比如版本号等
            - 元数据校验,校验其中的语义是否正确,继承的父类,以及父类是否被final修饰等
            - 字节码校验,确定程序语法是合法的.
            - 符号引用校验:通过权限定名是否能找到对应的类,类中是否有调用的方法,类,方法,属性的访问性等
         - 初始化:执行类构造器生成的<client>方法(包括static等代码块).五种强行初始化条件
            - 
         - 
      - 双亲委派模型
      ![blockchain](https://upload-images.jianshu.io/upload_images/13202633-4c819649aebff4df.png?imageMogr2/auto-orient/strip|imageView2/2/w/590/format/webp)
         - 每个类加载器收到了类加载请求,首先向父类进行委派加载,只有其父亲无法加载,他才尝试加载.
         - 使得类加载模型构成了一种层次结构.
         - 可以通过修改父类加载器实现类加密.
   - 类加载器
      - 启动类加载器
      - 扩展类加载器
      - 应用程序类加载器
   - java内存模型
      - 主内存:所有变量的存储
      - 工作内存:每个线程的变量副本(类似与高速缓存)
      - 操作(8个):
         - lock:辨识一个变量为一个线程独占
         - unlock:解除变量独占
         - read:主内存->工作内存
         - load:读取read中的获取的变量值到变量副本中
         - user:工作副本中变量读取
         - assign:变量下写入工作内存
         - store:工作内存->主内存
         - write:store中的内存写入
      - 原子性:
      - 可见性:一个线程修改了共享变量的值,其他线程能够立即得知这个修改.
      - 有序性:本线程中有序,其他线程中无序(1:指令冲排序,工作内存与主内存同步延迟);
      - hapees-before:判断数据之间冲突的重要准则.
