## 虚拟机相关
   - jvm自动内存管理
   ![blockchain](https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190208123758382-331193994.png)
      - 线程共享的区域:
         - 方法区:存储加载的类型信息,常量,静态变量(非堆),
         - 堆:存放对象实例,以及数组.
            - 如果没有完成对象的实例分配,并且堆无法扩展,抛出OOM异常.
      - 线程独占的区域
         - 虚拟机栈:每个方法执行时候的一个栈帧,用来存储对应的局部变量表,操作数栈,动态链接,方法出口等.
            - 抛出stackoverflow异常:申请的空间大于虚拟机设定的最大空间
            - 抛出outofmemory异常:栈动态扩展时,无法申请到空间.
         - 本地方法栈:虚拟机使用的本地(native方法)服务.
         - 程序计数器:当前线程执行字节码的行好指示器.
      - 直接内存(NIO等)
         - 基于通道和Buffer的IO方式,
   - 对象
      - 对象的创建:
      - 对象头的组成
---
   - 垃圾回收GC
      - 对象引用
         - 强引用: = new 类型的
         - 软引用: SoftReference实现软引用.系统将要内存溢出之前,会回收
         - 弱引用: WeakReference实现弱引用,下一次回收一定会回收的对象.
         - 虚引用: 
      - 可达性分析(标记算法):
         - 设定gc root,通过算法判断无法到达gc root的对象,将被标记回收.
      - 分代收集算法
         - JAVA堆分为新生代,老年代.
         - 新生代:大量对象死去,剩下的对象逐渐过度到老年代
         - 
---
   - 类加载
      - 类加载过程
      ![blockchain](https://upload-images.jianshu.io/upload_images/13202633-3cb11d1712a9efc9.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
         - 加载部分:
            - 根据类全限定名获取定义此类的二进制字节流.
            - 生成方法区运行时的数据结构
            - 堆中生成一个对应的Class对象,作为访问方法去的入口
         - 校验部分
            - 文件格式验证:字节码格式是否符合jvm要求,比如版本号等
            - 元数据校验,校验其中的语义是否正确,继承的父类,以及父类是否被final修饰等
            - 字节码校验,确定程序语法是合法的.
            - 符号引用校验:通过权限定名是否能找到对应的类,类中是否有调用的方法,类,方法,属性的访问性等
         - 初始化:执行类构造器生成的<client>方法.五种强行初始化条件
            - 
      - 双亲委派模型
      ![blockchain](https://upload-images.jianshu.io/upload_images/13202633-4c819649aebff4df.png?imageMogr2/auto-orient/strip|imageView2/2/w/590/format/webp)
         - 每个类加载器收到了类加载请求,首先向父类进行委派加载,只有其父亲无法加载,他才尝试加载.
         - 使得类加载模型构成了一种层次结构.
   - 类加载器
      - 启动类加载器
      - 扩展类加载器
      - 应用程序类加载器
   - java内存模型
      - 包括工作内存,主内存,以及相关的读写一致性