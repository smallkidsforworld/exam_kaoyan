# Redius
   - 基础命令:

   - 常用的数据结构
      1. __string__
      2. __list__:按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）
      3. __set__: String 类型的无序集合
      4. sorted set:
      5. __hash__:hash 特别适合用于存储对象
   - ***Redius淘汰策略:***
      1. __noeviction__: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。大多数写命令都会导致占用更多的内存(有极少数会例外。
      2. __allkeys-lru__:所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。
      3. __volatile-lru__:只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。
      4. __allkeys-random__:所有key通用; 随机删除一部分 key。
      5. __volatile-random__: 只限于设置了 expire 的部分; 随机删除一部分 key。
      6. __volatile-ttl__: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。
   - ***Redis的并发竞争问题如何解决?***   
   __单进程单线程模式__，采用 __队列模式__ 将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，利用setnx实现锁。
   - ***速度快的原因***:  
      1. __完全基于内存__，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
      2. __数据结构简单__，对数据操作也简单，Redis中的数据结构是专门进行设计的；
      3. __采用单线程__，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
      4. __使用多路I/O复用模型__，非阻塞IO；
   - ***持久化策略***
      1. RDB:数据以快照的形式保存在磁盘上
         1. __save触发方式__:
            - 该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。
         2. __bgsave触发方式__:  
            - 执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求
      2. AOF:Redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录
         1. __每修改同步always__：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好 
         2. __每秒同步everysec__：异步操作，每秒记录 如果一秒内宕机，有数据丢失
         3. __不同no__：从不同步.
   - ***Redis事务***
      1. 流程:MULTI(存储客户端指令到队列)->EXEC执行事务
      2. WATCH key [key ...] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。   
      2. 不支持回滚(错误原因可由编程管理)
   - ***内存分区***
      
   - ***分布式锁***

<!-- 
         服务器设计：这部分的主要内容就是：1）redis怎么接受客户端的输入、解析成指令；2）执行指令；3）怎么将指令结果返回给客户端。

aeEventLoop的设计和 《Linux高性能服务器编程》讲解的总体类似，输入输出缓冲区的设计和muduo讲解的基本一致，也有应用层的流量控制。

数据结构设计：各个数据结构的设计，怎么融合到aeEventLoop中，成为服务器的一部分，实现了各个指令功能。

分布式设计：1）主从同步replication；2）sentinel模式：用于解决主从同步中的主服务宕机怎么办，故障转移等；3）集群。 -->