# Redius
   - 常用的数据结构
      1. __string__
      2. __list__:按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）
      3. __set__: String 类型的无序集合
      4. sorted set:
      5. __hash__:hash 特别适合用于存储对象
   - ***Redius淘汰策略:***
      1. __noeviction__: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。大多数写命令都会导致占用更多的内存(有极少数会例外。
      2. __allkeys-lru__:所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。
      3. __volatile-lru__:只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。
      4. __allkeys-random__:所有key通用; 随机删除一部分 key。
      5. __volatile-random__: 只限于设置了 expire 的部分; 随机删除一部分 key。
      6. __volatile-ttl__: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。
   - Redis的并发竞争问题如何解决?   
   单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，利用setnx实现锁。
   - ***速度快的原因***:  
      1. __完全基于内存__，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
      2. __数据结构简单__，对数据操作也简单，Redis中的数据结构是专门进行设计的；
      3. __采用单线程__，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
      4. __使用多路I/O复用模型__，非阻塞IO；
   - ***持久化策略***
      1. RDB:数据以快照的形式保存在磁盘上
         1. __save触发方式__:
            - 该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。
         2. __bgsave触发方式__:  
            - 执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求
      2. AOF:Redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录
         1. __每修改同步always__：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好 
         2. __每秒同步everysec__：异步操作，每秒记录 如果一秒内宕机，有数据丢失
         3. __不同no__：从不同步.