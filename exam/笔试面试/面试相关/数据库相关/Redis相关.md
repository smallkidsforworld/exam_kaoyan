# [Redius](https://juejin.cn/post/6844904017387077640)
   - 基础命令:

   - 常用的数据结构
![blockchain](https://pic1.zhimg.com/v2-0b0e1d3eb01e47b3318318d49fb3de8c_b.jpg)
      1. __string__
      2. __list__:按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）
      3. __set__: String 类型的无序集合
      4. sorted set:
      5. __hash__:hash 特别适合用于存储对象
   - ***Redius淘汰策略:***
      1. __noeviction__: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。大多数写命令都会导致占用更多的内存(有极少数会例外。
      2. __allkeys-lru__:所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。
      3. __volatile-lru__:只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。
      4. __allkeys-random__:所有key通用; 随机删除一部分 key。
      5. __volatile-random__: 只限于设置了 expire 的部分; 随机删除一部分 key。
      6. __volatile-ttl__: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。
   - ***Redis的并发竞争问题如何解决?***   
   __单进程单线程模式__，采用 __队列模式__ 将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，利用setnx实现锁。
   - ***速度快的原因***:  
      1. __完全基于内存__，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
      2. __数据结构简单__，对数据操作也简单，Redis中的数据结构是专门进行设计的；
      3. __采用单线程__，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
      4. __使用多路I/O复用模型__，非阻塞IO；
   - ***持久化策略***
      1. RDB:数据以快照的形式保存在磁盘上
         1. __save触发方式__:
            - 该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。
         2. __bgsave触发方式__:  
            - 执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求
      2. AOF:Redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录
         1. __每修改同步always__：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好 
         2. __每秒同步everysec__：异步操作，每秒记录 如果一秒内宕机，有数据丢失
         3. __不同no__：从不同步.
   - ***Redis事务***
      1. 流程:MULTI(存储客户端指令到队列)->EXEC执行事务
      2. WATCH key [key ...] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。   
      2. 不支持回滚(错误原因可由编程管理)
   - ***内存分区***

   - ***分布式锁***
      - 分布式锁概念:保证一个方法或者属性在同一时间只能被一个线程使用.
      - CAP理论:一致性\可用性\分区容错性.只能满足其中两个.
      - 实现方法
         - 数据库实现:每次调用向数据库中插入一条记录,为调用的方法名以及调用方法的方法.
         - 基于redis实现:SETNX:当key值不存在的时候创建一个记录并返回1,否则,不进行操作,返回0.
            - SETNX可以直接加锁.SETNX (某一个关键字).lock <current unix time>
            - DEL foo.lock删除加在foo上的锁.
            - 设置超时机制.
   - ***布隆过滤器***
      - 通过多个hash函数以及一个位数组,存储redis中的对象.
   - ***[实际应用中缓存的集中情况](https://cloud.tencent.com/developer/article/1666384)***
      - **缓存穿透**:redis中没有,数据库中也没有,大量的查询给底层数据库带来了巨大的压力
         - 前端限定每秒查询次数:
         - 使用布隆过滤器
         ![blockchain](https://ask.qcloudimg.com/http-save/yehe-4752702/n41yh8r1hu.png?imageView2/2/w/1620)
      - **缓存击穿**:底层数据库有数据而缓存内没有数据,大量访问同时请求这个数据，就会将查询下沉到数据库层，此时数据库层的负载压力会骤增
         - 延长热点key的过期时间或者设置永不过期，如排行榜，首页等一定会有高并发的接口
         - 利用互斥锁保证同一时刻只有一个客户端可以查询底层数据库的这个数据，一旦查到数据就缓存至Redis内，避免其他大量请求同时穿过Redis访问底层数据库
      - **缓存雪崩**:大量的key几乎同时过期，然后大量并发查询穿过redis击打到底层数据库上，此时数据库层的负载压力会骤增
         - 在可接受的时间范围内随机设置key的过期时间，分散key的过期时间，以防止大量的key在同一时刻过期
         - 对于一定要在固定时间让key失效的场景(例如每日12点准时更新所有最新排名)，可以在固定的失效时间时在接口服务端设置随机延时，将请求的时间打散，让一部分查询先将数据缓存起来
         - 延长热点key的过期时间或者设置永不过期，这一点和缓存击穿中的方案一样
      - **缓存预热**:数据库内的热点数据缓存至Redis内再提供出去使用
         - 批任务，在启动项目时或定时去触发将底层数据库内的热点数据加载到缓存内.
      - **缓存更新**: 更新缓存,更新底层数据库   
         - cache aside:更新数据库,在更新缓存.
         - read through:更新数据库,在更新缓存
         - Write through:如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由缓存自己更新数据库；
         - Write behind caching:在更新数据的时候，只更新缓存，不更新数据库，缓存会异步地定时批量更新数据库；
      - **缓存降级**:当访问量急剧增加,损失其他次要服务,保证主服务的性能.
---
   - 主从复制：
      - 从节点执行slaueof[masterip][prot],存储主节点信息
      - 从节点中的定时任务发现主节点信息，建立和主节点的socket连接
      - 从节点发送Ping信号，主节点返回Pong，两边能互相通信
      - 连接建立后，主节点将所有数据发送给从节点（数据同步）各自维护对应的offset,通过offerset判断是否需要同步数据.
      
      - 主节点把当前的数据同步给从节点后，便完成了复制的建立过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。
   

 <!-- 
         服务器设计：这部分的主要内容就是：1）redis怎么接受客户端的输入、解析成指令；2）执行指令；3）怎么将指令结果返回给客户端。

aeEventLoop的设计和 《Linux高性能服务器编程》讲解的总体类似，输入输出缓冲区的设计和muduo讲解的基本一致，也有应用层的流量控制。

数据结构设计：各个数据结构的设计，怎么融合到aeEventLoop中，成为服务器的一部分，实现了各个指令功能。

分布式设计：1）主从同步replication；2）sentinel模式：用于解决主从同步中的主服务宕机怎么办，故障转移等；3）集群。 -->