周转时间 = 作业完成时间-作业提交时间
带权周转时间=作业周转时间/作业实际运作时间
响应时间：用户提交请求到系统首次响应的时间

调度算法
    1：先来先服务
        从就绪队列中选择最先进入该队列的进程。
        优缺点：算法简单，效率低。对长作业有利。有利于CPU繁忙，不利于I/O繁忙
    2：短进程优先
        从就绪队列中选择估计运行时间最短的进程。
        优缺点：其衡量时间相关系数较好（平均等待时间，平均周转时间最少），对长作业不利，不一定能够真正的实现短作业优先调度。
    3：优先级调度
        根据能否抢占：
            1）非剥夺式调度算法
            2）剥夺式调度算法
        根据进程优先级能否改变：
            1）静态优先级
            2）动态优先级
        进程优先级：
            1）系统进程 > 用户进程
            2) 交互型进程 > 非交互型进程
            3）I/O型进程 > 计算型进程
    4：高响应比优先调度算法
        响应比的变化规律：
            响应比Rp = (等待时间+要求服务时间)/要求服务时间
    5：时间片轮转调度
        主要用于分时系统。
        按照先来先服务，每个进程仅能运行一个时间片。
    6：多级反馈队列调度算法
        1：设置了多个就绪队列
        2：赋予各个队列中进程执行时间片大小各不相同。
        3：运行当前队列中的首个进程，若没有运行完必，放入第二队列的末尾。
    
问题回答：
    1：单项选择
    A,C,B,D,B,(B,E,C,D),D,B,D,B,C(11),A,D,B,B(15),B,B,(18待完成),……设计到大量的计算，因此将这部分延后
    
    
    
进程同步
    1：产生原因：进程由于并发执行，存在着不同的相互制约关系。
    2：临界资源：一次仅允许一个进程使用的资源。对临界资源的使用，必须互斥的进行。
        临界资源的访问过程：
            1：进入区：设置标志，标识当前进程正在使用临界区。
            2：临界区：每个进程中访问临界资源的代码称为临界区。
            3：退出区：清除访问的临界区标志
            4：剩余区：代码中的其他部分。

    3：同步：直接制约关系。需要某些位置上协调他们的工作次序而等待、传递消息所产生的制约关系。
    4：互斥：间接制约关系。访问临界资源等部分。
        禁止多个进程同时进入临界区：
            1：空闲让进：～
            2：忙则等待：当前临界区已有进程访问，其他试图进入的进程出于等待状态。
            3：有限等待：请求访问的进程，能够在有限时间内进入临界区
            4：让权等待：对于无法进入的进程释放资源。
        是写临界区互斥访问的基本方法
            1：软件实现方法:perter-son方法
            2：硬件实现方法：原方法
                1）中断屏蔽。关闭中断->取消线程切换
                2）硬件指令方法。testandset指令：原子操作
                
        信号量：功能较强的机智，解决同步互斥问题
            1：只能被两个标准的原语wais(S)与signal(S)，可记作：P操作，V操作
            2：对于原语操作的描述：
                1）但使用S标记资源数目
                    wait(S){//占有资源
                        while(S<=0);
                        S=S-1;
                    }
                    signal(S){//释放资源
                        S=S+1;
                    }
                2）使用S记录资源数目，使用L记录等待资源列表。    
                类似地：
                    typedef struct{
                        int value;
                        struct process *L;
                    }semaphore
                    wait(semaphore S){
                        s.value--；
                        while(s<0){
                            S.L.add(process);
                            block(S.L);
                        }
                    }
                    signal(semaphore S){
                        s.value++;
                        if(s<=0){
                            P=remove a process P from L;
                            wakeup(P);
                        }
                    }
    
            3：使用信号量实现同步
                p2中需要使用P1中x的执行结果，因此。

                semaphore S = 0;
                P1(){
                    x；//执行程序部分内容；
                    V(S); //提示这部分已经运行完毕。（释放资源）
                }
                P2(){
                    ……
                    P(S);   //检查当前是否能够运行
                    y;   
                }
            4：使用信号量实现互斥
                S作为P1，P2进程的互斥量，初始资源1，把临界区置于P，V之间。
                semophore S = 1;
                P1(){
                    ……;
                    P(S);//表示P1当前占据资源
                    ……；//临界区
                    V(S);//表示P1当前释放资源
                }
                P2(){
                    ……;
                    P(S);//表示P2当前占据资源
                    ……；//临界区
                    V(S);//表示P2当前释放资源
                }
            5：一般分析进程同步和互斥的方法步骤：
                1）关系分析；找出问题中的进程数目，分析他们之间的同步和互斥关系。同步互斥，前驱等内容根据实例进行编写。
                2）整理思路：找出解决问题的关键点，并根据做过的题目找出求解的思路。根据进程操作流程确定P，V操作的大致顺序。
                3）设置信号量：根据以上两步，确定信号量以及对应的初始值。
    管程：进程同步工具。
        1）定义：
            管程：系统中的共享资源，以及资源对应的操作定义为一组过程，并且该过程还可以根据资源的情况，或接受或阻塞进程的访问。
        2）组成：
            1：管程的名称
            2：局部于管程内部的共享结构数据说明
            3：对该数据结构进行操作的一组过程
            4：对局部于管程内部的共享数据设置初始值的语句。
        3）每次仅允许一个进程调用其中的take_away()以及give_back().只有当其运行完调用的过程后，下个进程才能够开始运行它调用的过程。各个进程只能串行执行管程中的过程。
        4）条件变量（阻塞原因）
            1）x.wait：当x对应的条件不满足的时候，正在调用管程的进程调用x.wait将自己插入x条件的等待队列。
            2）x.signal：x对应的条件发生了变化，调用x.signal，唤醒一个因x条件而阻塞的进程。   
        
        
    经典同步问题：
        1）生产者消费者问题：
            1）考虑：生产者消费者不能同时操作->缓冲区:互斥。  当生产者生产后，消费者才能够消费->协作过程。
            2）使用mutex表示缓冲区资源，使用变量empty，full记录缓冲池中空、满缓冲区数。
            
semaphore mutex=1;
semaphore full=0;
semaphore empty=n;
produce(){
    while(1){
        create_an_item;
        P(empty);//empty--
        P(mutex);//mutex--，如果大于等零，执行
        add item to buffer;
        V(mutex);
        V(full);//full资源+1；
    }
}

consumer(){
    while(1){
        p(full);
        p(mutex);
        remove an item from buffer;
        V(mutex);
        V(empty);
        consumer the data;
    }

}
            
    
    2）读者-写者问题：
    问题分析：读者可以一起读，写只能一个写者。写的时候不能有人在读
    使用count记录读者人数0的时才能写。
    使用write记录当前是否在写
    
int count=0;
semaphore mutex=1;
semaphore rw=1;
read(){
    while(1){
        p(mutex);
        if(count==0)
            p(rw);
        count++;
        V(mutex);
        reaading;
        P(mutex);
        count--;
        if(count==0)
            V(RW);
        V(mutex);
    }
}
    
write(){
    while(1){
        P(rw);
        write;
        V(rw);
    }
}    
    
    
    
    
    
    
    
    
    
    
    
    