<!-- TOC -->

- [1. 死锁](#1-死锁)
    - [1.1. 死锁的定义](#11-死锁的定义)
    - [1.2. 产生死锁的原因](#12-产生死锁的原因)
    - [1.3. 产生死锁的条件](#13-产生死锁的条件)
        - [1.3.1. 互斥条件](#131-互斥条件)
        - [1.3.2. 不剥夺条件](#132-不剥夺条件)
        - [1.3.3. 请求保持](#133-请求保持)
        - [1.3.4. 循环等待](#134-循环等待)
    - [1.4. 死锁的处理策略](#14-死锁的处理策略)
        - [1.4.1. 死锁预防](#141-死锁预防)
        - [1.4.2. 避免死锁](#142-避免死锁)
        - [1.4.3. 死锁的检测和预防](#143-死锁的检测和预防)
            - [1.4.3.1. 死锁处理策略比较](#1431-死锁处理策略比较)
- [课后习题 QA:](#课后习题-qa)

<!-- /TOC -->
# 1. 死锁
## 1.1. 死锁的定义  
   多个进程因为竞争资源造成的僵局（相互等待）。
## 1.2. 产生死锁的原因
   - 1.2.1. 系统资源竞争   
   - 1.2.2. 进程推进顺序非法
## 1.3. 产生死锁的条件
### 1.3.1. 互斥条件  
进程对于资源的使用具有排它性.资源在一定时间内,只能有一个进程访问.
### 1.3.2. 不剥夺条件  
进程对于所占有的资源在运行完成之前,不能被其他进程剥夺,只能由自己释放.
### 1.3.3. 请求保持
进程已经保持了至少一个资源,但又提出了新的资源请求,而该资源又被其他进程所占用,此时进程阻塞,但不是放已经拥有的资源.
### 1.3.4. 循环等待
存在进程等待链,链中每一个进程所拥有的资源被链中下一个进程请求
## 1.4. 死锁的处理策略
### 1.4.1. 死锁预防
破坏死锁产生条件中至少一个
### 1.4.2. 避免死锁
在资源分配中,采用某种策略.避免系统进入不安全状态,从而避免死锁.
### 1.4.3. 死锁的检测和预防
通过系统性检测及时的检测死锁,然后采取某种措施接触死锁.
#### 1.4.3.1. 死锁处理策略比较
||资源分配策略|各种可能模式|主要优点|主要缺点|
|---|---|---|---|--
|死锁预防|保守,资源宁可闲置.|一次分配所有的资源,资源剥夺,资源按序分配|适用于突发处理的进程,资源不剥夺|效率低,不能够灵活的申请资源|
|避免死锁|预防和检测的折中|寻找可能的安全顺序|不必剥夺|必须知道需要的资源需求,进程不能长时间阻塞|
|死锁检测和预防|宽松,只要允许就分配资源|定期检查死锁是否已经发生|不延长进程初始化时间,允许对死锁进行现场处理|通过剥夺死锁,造成损失|
   - 死锁预防
   破坏四个必要条件之一即可.
   - 避免死锁
      1. **系统安全状态**  
      允许系统动态申请资源,系统分配资源前,判断此次资源分配是否安全:若安全,则允许分配,否则,不允许.
      2. **银行家算法**
      操作系统按照一定的规则分配资源给进程.进程运行前声明使用的最大资源量,当进程执行过程中申请资源时候,首先检测进程所使用的资源+申请的资源是否大于声明的最大资源量.如果超过,拒绝分配;否则,看当前系统资源是否足够,足够则分配,不足,则**推迟分配**
   - 死锁检测和预防
      1. 死锁的条件=>资源分配图不可以完全简化->资源分配图不能消去所有边
      **死锁定理**:
         “S为死锁状态的充分必要条件是:当且仅当S状态的资源分配图是不可完全简化的。该充分条件被称为死锁定理
      2. 死锁解除
         - 资源剥夺
         - 撤销进程
         - 进程回滚

---
# 课后习题 QA:
1-5:C,C,D,B,D  
6-10:B,B,B,C,B 
11-15:B,B,C,A,D
16-20:B,,D,A,D,(20题,没有太清楚)
21-25:D,B,B,C,C
26-30:B,D,D,D,B
31-34:C,C,D,B
论述题:  
1. 2)->1)->3)
2. **不太会**
```java
// 转入用户与转出用户
semphore in_user=out_user=1;
P(thread_one){
   while(1){
      P(out_user);
      Produce(A){
         out_user.val --;
      };
      V(out_user);
   }
}

P(thread_two){
   while(1){
      P(in_user);
      Produce(A){
         in_user.val ++;
      };
      V(in  _user);
   }
}
```
3. 会发生死锁
   - 原因:当进程P1,与P2分别获得R1与R2后,在继续申请资源就导致二者发生循环等待.(系统资源竞争,进程推进顺序不当)必要条件:
      1. 循环等待
      2. 资源不剥夺
      3. 资源独占
      4. 请求保持
   