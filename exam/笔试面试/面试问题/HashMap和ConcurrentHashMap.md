# HashMap
   - 默认装填因子0.75 默认表长16.
   - 底层实现:数组+链表+红黑树.
   - 每次扩容,增大两倍.扩容条件,达到装填因子.
   - HashMap根据链地址法（拉链法）来解决冲突，在jdk1.8中，如果链表长度大于8且节点数组长度大于64的时候，就把链表下所有的节点转为红黑树
   - put:头部插入链表哈.
   - HashMap的扩容机制就是重新申请一个容量是当前的2倍的桶数组，然后将原先的记录逐个重新映射到新的桶里面，然后将原先的桶逐个置为null使得引用失效。  
   - 线程不安全原因:
      - 1)当多个线程进行put操作的时候,由于命中了相同链表的相同位置,插入后会导致数据的覆盖.
      - 2)多个线程进行resize的时候,出现了循环技术的方式.(这个在jdk1.8后很少出现了,因为此时采用的尾部插入,导致不会出现循环的问题.)
# ConcurrentHashMap
   - 默认分为16个桶.
   - 底层采用分段的数组+链表实现，线程安全
   - 扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容
   - 有些方法需要跨段，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁
   -允许多个修改操作并发进行，其关键在于使用了锁分离技术
   - 通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。
   - 1.8 新特性:
      - 